const { createClient } = require('@supabase/supabase-js');

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

module.exports = async (req, res) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  // ==================== GET - Fetch deals from pipeline ====================
  if (req.method === 'GET') {
    try {
      console.log('[Deals API] Fetching deals from pipeline...');

      // Get all contacts in "Active Deals" or "Closed Won" stages
      const { data: contacts, error: contactsError } = await supabase
        .from('contacts')
        .select('*')
        .in('stage', ['active_deals', 'closed_won', 'active', 'deal'])
        .order('updated_at', { ascending: false });

      if (contactsError) {
        console.error('[Deals API] Error fetching contacts:', contactsError);
        throw contactsError;
      }

      console.log('[Deals API] Found', contacts?.length || 0, 'contacts in deal stages');

      // Transform contacts to deal format
      const deals = (contacts || []).map(contact => {
        // Determine tier based on contract value or other criteria
        let tier = 'foundations';
        const contractValue = contact.contract_value || contact.deal_value || 0;
        
        if (contractValue >= 300000) {
          tier = 'alliance';
        } else if (contractValue >= 100000) {
          tier = 'architecture';
        }

        // Determine status
        let status = 'active';
        if (contact.stage === 'closed_won' || contact.status === 'active') {
          status = 'active';
        } else if (contact.status === 'pending' || contact.stage === 'pending') {
          status = 'pending';
        }

        return {
          id: contact.id,
          clientName: contact.name,
          company: contact.company,
          email: contact.email,
          tier: tier,
          dealValue: contractValue,
          contractValue: contractValue,
          type: contact.payment_model || 'Annual',
          paymentModel: contact.payment_model || 'fixed',
          status: status,
          startDate: contact.deal_start_date || contact.created_at,
          renewalDate: contact.renewal_date,
          currentPhase: contact.current_phase || 'Phase 1: Foundation',
          progress: contact.progress_percentage || 0,
          
          // Systems/deliverables (if stored)
          systemsDelivered: contact.systems_delivered || [],
          
          // Metrics
          metrics: {
            leadsGenerated: contact.leads_generated || 0,
            qualificationRate: contact.qualification_rate || 0,
            pipelineValue: contact.pipeline_value || 0,
            revenueGenerated: contact.revenue_generated || 0,
            roi: contact.roi || 0
          },
          
          // Additional fields
          leadsGenerated: contact.leads_generated || 0,
          revenueGenerated: contact.revenue_generated || 0,
          roi: contact.roi || 0,
          commissionEarned: contact.commission_earned || 0,
          
          created: contact.created_at,
          updated: contact.updated_at
        };
      });

      // Calculate stats
      const activeDeals = deals.filter(d => d.status === 'active');
      const totalValue = deals.reduce((sum, d) => sum + (parseFloat(d.contractValue) || 0), 0);
      const totalSystems = deals.reduce((sum, d) => sum + (d.systemsDelivered?.length || 0), 0);
      const avgDealSize = activeDeals.length > 0 ? totalValue / activeDeals.length : 0;

      const stats = {
        activeDeals: activeDeals.length,
        totalValue: totalValue,
        systemsDeployed: totalSystems,
        avgDealSize: avgDealSize
      };

      console.log('[Deals API] ✅ Returning', deals.length, 'deals');

      return res.status(200).json({
        success: true,
        data: {
          deals: deals,
          stats: stats
        },
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      console.error('[Deals API] GET Error:', error);
      return res.status(500).json({
        success: false,
        error: error.message
      });
    }
  }

  // ==================== PUT - Update deal/contact ====================
  if (req.method === 'PUT') {
    try {
      const { id, status, ...updateData } = req.body;

      if (!id) {
        return res.status(400).json({
          success: false,
          error: 'Deal ID is required'
        });
      }

      // Map frontend field names to database field names
      const dbUpdateData = {
        updated_at: new Date().toISOString()
      };

      if (status) dbUpdateData.status = status;
      if (updateData.contractValue) dbUpdateData.contract_value = updateData.contractValue;
      if (updateData.currentPhase) dbUpdateData.current_phase = updateData.currentPhase;
      if (updateData.progress) dbUpdateData.progress_percentage = updateData.progress;
      if (updateData.leadsGenerated) dbUpdateData.leads_generated = updateData.leadsGenerated;
      if (updateData.revenueGenerated) dbUpdateData.revenue_generated = updateData.revenueGenerated;
      if (updateData.roi) dbUpdateData.roi = updateData.roi;

      const { data, error } = await supabase
        .from('contacts')
        .update(dbUpdateData)
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;

      console.log('[Deals API] ✅ Deal updated:', id);

      return res.status(200).json({
        success: true,
        data: data,
        message: 'Deal updated successfully'
      });

    } catch (error) {
      console.error('[Deals API] PUT Error:', error);
      return res.status(500).json({
        success: false,
        error: error.message
      });
    }
  }

  return res.status(405).json({ 
    success: false,
    error: 'Method not allowed' 
  });
};
